
dfs

->turn = the variable to hold the current turn

typedef struct	s_allsort
{
	long	max_turn; ->current max turn
	long	turn; ->
	long	tmp[SORTLIMIT_OVER6 + 10]; ->current answer
	long	ans[SORTLIMIT_OVER6 + 10]; ->final answer
	long	pre; ->
	long	awant; ->
	long	size; -> total number of input number?
	long	fin; ->
	} t_sort;

void dfs(t_dlst *a, t_dlst *b, t_allsort *t, long turn)
{
	long command;

-> if the current turn is the same or bigger than the max, end;
	if (turn >= t->max_turn)
		return ;

->if is_sorted is success, update the current answer
if (is_sorted(a))
	return (ans_update(turn, t));

->check possible operations
	ops = 0;
	while (ops <= 11)
	{
		// avoid useless command (e.g. pa -> ba)
		if (avoid_check(command, t) || turn >= t->max_turn)
			return ;
		//apply operation(a, b, command, true);
			continue;
		//check next ops
			dfs(a, b, t, turn + 1);
		// back track -> do the opposite and recover the last one
			
		ops++;
	}
}

ans_update(turn, t_sort *t)
{
	long	i;

	t->max_turn = turn;
	i = -1;
	while (++i < turn)
		t->ans[i] = t->tmp[i];
}

->apply the operation

long	recover(long command)
{
	if (command == PA)
		return (PB);
	if (command == PB)
		return (PA);
	if (command == RA)
		return (RRA);
	if (command == RB)
		return (RRB);
	if (command == RR)
		return (RRR);
	if (command == RRA)
		return (RA);
	if (command == RRB)
		return (RB);
	if (command == RRR)
		return (RR);
	return (command);
}


bool	change_dlst(t_dlst *a, t_dlst *b, long command, bool exec)
{
	if (!exec)
		command = recover(command);
	if (command == SA)
		return (sa(a));
	if (command == SB)
		return (sa(b));
	if (command == SS)
		return (ss_stop(a, b));
	if (command == PA)
		return (pa(a, b));
	if (command == PB)
		return (pa(b, a));
	if (command == RA)
		return (ra(a));
	if (command == RB)
		return (ra(b));
	if (command == RR)
		return (rr_stop(a, b));
	if (command == RRA)
		return (rra(a));
	if (command == RRB)
		return (rra(b));
	if (command == RRR)
		return (rrr_stop(a, b));
	return (true);
}

bool	avoid_check(long command, t_allsort *t)
{
	if (command == SA && (t->pre == SA || t->pre == SB || t->pre == SS))
		return (true);
	if (command == SB && (t->pre == SA || t->pre == SB || t->pre == SS))
		return (true);
	if (command == SS && (t->pre == SA || t->pre == SB || t->pre == SS))
		return (true);
	if (command == PA && (t->pre == PB))
		return (true);
	if (command == PB && (t->pre == PA))
		return (true);
	if (command == RA && (t->pre == RRA || t->pre == RRR))
		return (true);
	if (command == RB && (t->pre == RRB || t->pre == RRR))
		return (true);
	if (command == RR && (t->pre == RRA || t->pre == RRB || t->pre == RRR))
		return (true);
	if (command == RRA && (t->pre == RA || t->pre == RR))
		return (true);
	if (command == RRB && (t->pre == RB || t->pre == RR))
		return (true);
	if (command == RRR && (t->pre == RA || t->pre == RB || t->pre == RR))
		return (true);
	return (false);
}
